# -*- coding: utf-8 -*-
"""server-lab3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BNANFoSp7Q0RaYys__9i7cPxwQSNcOuV

CONFIG
"""

CONFIG_PARAMS = {
    'SERVER_IP_ADDRESS': '127.0.0.1',
    'SERVER_PORT': 8081,
    'SERVER_MAX_CLIENTS': 1,
    'SERVER_MAX_WORKERS': 2,
    'EXIT_MESSAGE': 'exit'
}

"""SERVER"""

import socket#Para comunicarse por la red
import threading#Para multiples conexiones
import time#Manejo del tiempo
import pickle#Para serializacion de datos
import struct#Para manejar datos binarios estructurados

# Configuration Parameters
IP_ADDRESS = CONFIG_PARAMS['SERVER_IP_ADDRESS']
PORT = CONFIG_PARAMS['SERVER_PORT']
MAX_CLIENTS = CONFIG_PARAMS['SERVER_MAX_CLIENTS']
MAX_WORKERS=CONFIG_PARAMS['SERVER_MAX_WORKERS']

#Clientes y workers conectados
LIST_OF_CLIENTS = []
LIST_OF_WORKERS = []

def handle_worker(worker_socket, worker_address):
    try:
        while True:
            pass  # Solamente mantiene la conexion con el worker
    except Exception as ex:
      print(f'Error de worker {worker_address[0]}: {ex}')

    finally:
      print(f" Worker desconectado: {worker_address}")
      #Quitar al worker de la lista de workers conectados y cerrar su socket
      LIST_OF_WORKERS.remove(worker_socket)
      worker_socket.close()

def recv_exact(socket, n):
    #Recibir exactamente n bytes desde socket, debido a que habia problemas si no recibia todos los bytes a la vez
    data = b''
    while len(data) < n:
        chunk = socket.recv(n - len(data))
        if not chunk:
            raise Exception("Conexión cerrada antes de recibir todos los datos.")
        data += chunk
    return data



def handle_client(client_socket, client_address):
  try:

    #Esperar hasta tener 2 workers
    while len(LIST_OF_WORKERS) < 2:
      time.sleep(1)  
    
    # Recibir tarea del cliente
     
    data_length=recv_exact(client_socket,4)#Recibir tamaño de la informacion a leer
    data_length = struct.unpack('!I', data_length)[0]#Unpack tamaño como un entero

    data = recv_exact(client_socket,data_length)#Data del cliente serializada
    task_data = pickle.loads(data)  # Deserializa los datos

    #data = client_socket.recv(4194304)

    #Preparar informacion para los workers
    vector = task_data["vector"]
    time_limit = task_data["limite"]
    algoritmo=task_data["algoritmo"]
    
    #Obtener workers de la lista de workers
    worker_0 = LIST_OF_WORKERS.pop(0)
    worker_1 = LIST_OF_WORKERS.pop(0)
    # Asignando tarea al worker_0
    
    
    #No hay nada organizado  entonces en sorted hay una lista vacia
    task_data={"unsorted_vector": vector,"sorted_vector":[], "time_limit": time_limit,"algoritmo":algoritmo,}
    total_time=0
    T=True
    while T:

        ser_data=pickle.dumps(task_data)#Serializar task_data
        data_length=len(ser_data)#longitud de bytes de la data
        print(" Enviando tarea al worker_0...")
        worker_0.sendall(struct.pack('!I', data_length)) #Enviar longitud como datos binarios estructurados
        worker_0.sendall(ser_data)#Enviar task_data serializada
        print("Esperando respuesta del worker_0")
        try:

            response_length=recv_exact(worker_0, 4)#Recibr la longitud de la respuesta por parte del worker_0 y de 4 bytes
            response_length=struct.unpack('!I', response_length)[0]#Unpack tamaño de datos como un entero

            response=recv_exact(worker_0,response_length)#Respuesta del worker_0

            response_data=pickle.loads(response)#Deserializar la respuesta

            total_time+=response_data["time_taken"]

            #response = worker_0.recv(4194304)  # Esperar respuesta
      

            print("Respuesta recibida del worker_0")

            if response_data["completed"]:#Revisar si es necesario enviarle el resto de la tarea al worker_1
                pass
            else:
                # Si worker_0 no termino de organizar el vector, se le asigna el resto de la tarea al worker_1
        
                print(" Enviando tarea a Worker_1...")

                #Preparando y enviando informacion a worker_1
                task_data={"unsorted_vector": response_data["unsorted_vector"], "time_limit": time_limit,"algoritmo":algoritmo,"sorted_vector":response_data["sorted_vector"]}
                ser_data=pickle.dumps(task_data)
                data_length=len(ser_data)

                worker_1.sendall(struct.pack('!I', data_length)) 
                worker_1.sendall(ser_data)
                print("Esperando respuesta del worker_1")
                #Recibir longitud en bytes, luego recibir la respuesta completa
                response_length=recv_exact(worker_1, 4)
                response_length=struct.unpack('!I', response_length)[0]

                response = recv_exact(worker_1, response_length)
                response_data=pickle.loads(response)

                total_time+=response_data["time_taken"]

                #response = worker_1.recv(4194304)
                print(" Respuesta recibida de worker_1")

        

        except Exception as ex:
            print("Error recibiendo respuestas de los workers")

        if(response_data["completed"]):
            T=False
        task_data=response_data

    # Enviar resultado al cliente
    print("Vector organizado")
    print("Enviando respuesta al cliente...")
    
    response_data["total_time"]=total_time

    LIST_OF_WORKERS.append(worker_0)
    LIST_OF_WORKERS.append(worker_1)

    ser_data=pickle.dumps(response_data)#Serializar
    data_length=len(ser_data)#Obtener longitud
    client_socket.sendall(struct.pack('!I', data_length)) #Primero enviar longitud como datos binarios estructurados
    client_socket.sendall(ser_data)#Enviar data serializada
    
    

  except Exception as ex:
    print(f" Error procesando cliente {client_address}: {ex}")
  finally:
    #Cerrar conexion con cliente
    client_socket.close()



def start_server():
  server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
  server_socket.bind((IP_ADDRESS, PORT))
  server_socket.listen(MAX_CLIENTS+MAX_WORKERS)
  print(" Esperando conexiones...")

  try:
    while True:
      #Aceptar conexiones
      client_socket, client_address = server_socket.accept()
      #Recibir clientes hasta alcanzar el numero maximo de clientes, despues de esto las nuevas conexiones seran workers
      if not(len(LIST_OF_CLIENTS)==MAX_CLIENTS):
        LIST_OF_CLIENTS.append(client_socket)#Añadir a lista de clientes
        print("Cliente conectado")
        client_thread = threading.Thread(target=handle_client, args=(client_socket, client_address))#Hilo para manejar conexion
        client_thread.start()
      else:
        LIST_OF_WORKERS.append(client_socket)#Añadir a lista de workers
        print("Worker_",len(LIST_OF_WORKERS)-1," conectado")
        client_thread = threading.Thread(target=handle_worker, args=(client_socket, client_address))#Hilo para manejar conexion
        client_thread.start()
      print(client_address[0], 'conectado')

  except Exception as ex:
    print(f'Error aceptando conexiones: {ex}')
    print('Cerrando servidor...')
  finally:
    #Cerrar todas las conexiones de clientes y workers
    for client in LIST_OF_CLIENTS:
      client.close()
    for worker in LIST_OF_WORKERS:
      worker.close()
    server_socket.close()

if __name__ == '__main__':
    #Iniciar
    print("Servidor iniciado")
    start_server()