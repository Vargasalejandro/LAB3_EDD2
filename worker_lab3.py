# -*- coding: utf-8 -*-
"""worker-lab3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_Il4R1ATOF6EM7GhbyGWkgolkzco0JW2

CONFIG
"""

CONFIG_PARAMS = {
    'SERVER_IP_ADDRESS': '127.0.0.1',
    'SERVER_PORT': 8081,
    'SERVER_MAX_CLIENTS': 1,
    'SERVER_MAX_WORKERS': 2,
    'EXIT_MESSAGE': 'exit'
}

"""WORKER"""

import socket#Para comunicarse por la red
import time#Manejo del tiempo
import pickle#Para serializacion de datos
import struct#Para manejar datos binarios estructurados

# Configuration Parameters
SERVER_IP_ADDRESS = CONFIG_PARAMS['SERVER_IP_ADDRESS']
SERVER_PORT = CONFIG_PARAMS['SERVER_PORT']
EXIT_MESSAGE = CONFIG_PARAMS['EXIT_MESSAGE']

def Mergesort(vector, start, end, start_time, time_limit):
    # Verificar si el tiempo transcurrido ha excedido el límite establecido
    if time.perf_counter() - start_time > time_limit:
        return  # Detener la ejecución si se supera el tiempo límite

    # Caso base
    if start >= end:
        return

    # Encontrar el índice medio
    mid = (start + end) // 2

    # Recursivamente ordenar la mitad izquierda del vector
    Mergesort(vector, start, mid, start_time, time_limit)

    # Recursivamente ordenar la mitad derecha del vector
    Mergesort(vector, mid + 1, end, start_time, time_limit)

    # Antes de mezclar, verificar nuevamente si se ha excedido el tiempo límite
    if time.perf_counter() - start_time > time_limit:
        return

    # Mezclar las dos mitades ordenadas
    merge(vector, start, mid, end)


def merge(vector, start, mid, end):
    # Crear un arreglo auxiliar para la mezcla
    aux = [0] * (end - start + 1)

    # Inicializar punteros
    i, j, k = start, mid + 1, 0

    # Comparar y combinar elementos de ambas mitades
    while i <= mid and j <= end:
        if vector[i] <= vector[j]:
            aux[k] = vector[i]
            i += 1
        else:
            aux[k] = vector[j]
            j += 1
        k += 1

    # Copiar los elementos restantes de la mitad izquierda
    while i <= mid:
        aux[k] = vector[i]
        i += 1
        k += 1

    # Copiar los elementos restantes de la mitad derecha
    while j <= end:
        aux[k] = vector[j]
        j += 1
        k += 1

    # Copiar los elementos del arreglo auxiliar de vuelta al original
    for k in range(len(aux)):
        vector[start + k] = aux[k]

def combine(left, right):
    
    result = []  # Lista que almacenará los elementos de las dos listas combinadas
    
    # Mientras ambas listas (left y right) tengan elementos, compararlas y añadir el menor a result
    while left and right:
        # Compara el primer elemento de cada lista y añade el más pequeño a result
        if left[0] < right[0]:
            result.append(left.pop(0))  # Elimina y añade el primer elemento de left
        else:
            result.append(right.pop(0))  # Elimina y añade el primer elemento de right

    # Si quedan elementos en left o right (una de las listas podría no estar vacía)
    # los añadimos directamente al final de result
    result.extend(left)  # Añade los elementos restantes de left
    result.extend(right)  # Añade los elementos restantes de right

    # Devuelve la lista combinada y ordenada
    return result



def Heapsort(vector, start_time, time_limit):
    # Obtiene la longitud del vector para calcular el tamaño del heap(monticulo)
    n = len(vector)

    # Construir el heap
    # La construcción del heap comienza desde el último nodo que tiene hijos, es decir, desde n//2 - 1 hacia atrás
    # El heap se construye (asegurandose de que el padre sea mayor que sus hijos)
    for i in range(n // 2 - 1, -1, -1):
        # Verifica si el tiempo ha excedido el límite. Si es así, devuelve el vector parcialmente ordenado
        
        heap(vector, n, i, start_time, time_limit)  # Llamada a la función heap para ajustar el heap
        
        if  time.perf_counter() - start_time > time_limit:
            return vector  # Devuelve el vector parcialmente ordenado si se excede el tiempo límite  
    # Extraer elementos del heap y reconstruir el heap en cada paso
    for i in range(n - 1, 0, -1):

        # Verifica si el tiempo ha excedido el límite. Si es así, devuelve el vector parcialmente ordenado
        if  time.perf_counter() - start_time > time_limit:
            return vector  # Devuelve el vector parcialmente ordenado si se excede el tiempo límite
        # Intercambia el primer elemento (máximo) con el último elemento del heap
        vector[i], vector[0] = vector[0], vector[i]

        #Usar heap para asegurarse que el heap sigue siendo válido después del intercambio
        heap(vector, i, 0, start_time, time_limit)

    # Devuelve el vector completamente ordenado (si el tiempo no ha excedido el límite)
    return vector


def heap(arr, n, i, start_time, time_limit):
    # Inicializa la variable 'largest' como el índice del nodo actual
    largest = i
    left = 2 * i + 1  # Índice del hijo izquierdo
    right = 2 * i + 2  # Índice del hijo derecho

    # Si el hijo izquierdo existe y es mayor que el nodo actual, actualiza 'largest'
    if left < n and arr[left] > arr[largest]:
        largest = left
    
    # Si el hijo derecho existe y es mayor que el nodo actual o el hijo izquierdo, actualiza 'largest'
    if right < n and arr[right] > arr[largest]:
        largest = right

    
    # Si largest es diferente del nodo actual, se intercambia el nodo actual con el hijo mayor y llama recursivamente a heap en el sub-árbol afectado
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # Intercambia el nodo con el hijo mayor
        heap(arr, n, largest, start_time, time_limit)  # Llama recursivamente a heap en el sub-árbol afectado


def Quicksort(vector, start_time, time_limit):
    # Verificar si el tiempo límite se ha excedido. Si se ha excedido, devuelve el vector parcialmente ordenado
    if time.perf_counter() - start_time > time_limit:
        return vector  # Devuelve el vector sin cambios si el tiempo ha excedido el límite

    # Caso base
    if len(vector) <= 1:
        return vector

    # Elegir pivote
    pivot = vector[0]

    # Elementos menores o iguales al pivote
    left = [x for x in vector[1:] if x <= pivot]
    
    # Elementos mayores que el pivote
    right = [x for x in vector[1:] if x > pivot]

    # Verificar el tiempo antes de realizar las llamadas recursivas
    # Si se ha excedido el tiempo límite, devuelve la lista parcialmente ordenada
    if time.perf_counter() - start_time > time_limit:
        return left + [pivot] + right  # Devuelve la lista hasta este punto sin ordenar recursivamente

    # Realizar las llamadas con las sublistas(left,right)
    left_sorted = Quicksort(left, start_time, time_limit)
    right_sorted = Quicksort(right, start_time, time_limit)

    # Combina las sublistas ordenadas con el pivote en el medio para devolver el vector ordenado
    return left_sorted + [pivot] + right_sorted



def split_sorted_unsorted(vector):
    #Divide un vector en su parte ordenada y desordenada
    for i in range(1, len(vector)):
        if vector[i] < vector[i - 1]:
            # Se encuentra donde el vector ya no esta ordenado
            return vector[:i], vector[i:]
    return vector, []  # Si todo esta ordenado

def process_task(task_data):
    #Organizar los datosrecibidos
    vector = task_data["unsorted_vector"]#Parte desordenada
    sorted=task_data["sorted_vector"]#Parte ordenada
    algoritmo=task_data["algoritmo"]
    time_limit=task_data["time_limit"]

    #Obtener el tiempo de inicio
    start_time=time.perf_counter()

    #Determinar el algoritmo de procesamiento
    print("Ordenando el vector")
    if algoritmo==1:
      Mergesort(vector,0,len(vector)-1,start_time,time_limit)
    elif algoritmo==2:
      vector=Heapsort(vector,start_time,time_limit)
    elif algoritmo==3:
      vector=Quicksort(vector,start_time,time_limit)

    #Calcular el tiempo que se demoro el worker
    time_taken=time.perf_counter()-start_time

    print("Dividiendo el vector en parte ordenada y desordenada")
    #Del vector que justo se ordeno, se divide en una parte ordenada y otra desordenada
    vector,unsorted=split_sorted_unsorted(vector)
    #Las dos partes ordenadas se mezclan, la desordenada permanece aparte
    print("Obteniendo la nueva parte ordenada del vector")
    sorted=combine(sorted,vector)

    #CHECK
    print("sorted:",len(sorted))
    print("unsorted:",len(unsorted))

    #Determinar si se complete la tarea 
    if time_taken>time_limit:
      return {"sorted_vector": sorted, "time_taken": time_taken,"completed":False,"unsorted_vector":unsorted,"algoritmo":algoritmo,"time_limit":time_limit}
    else:
      return {"sorted_vector": sorted, "time_taken": time_taken,"completed":True,"unsorted_vector":unsorted}

def recv_exact(socket, n):
    #Recibir exactamente n bytes desde socket, debido a que habia problemas si no recibia todos los bytes a la vez
    data = b''
    while len(data) < n:
        chunk = socket.recv(n - len(data))
        if not chunk:
            raise Exception("Conexión cerrada antes de recibir todos los datos.")
        data += chunk
    return data

def start_worker():

    try:
      print("Intentando conectarse con el servidor")
      worker_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
      worker_socket.connect((SERVER_IP_ADDRESS, SERVER_PORT))  # Conexión al servidor
      print("Conexion establecida con el servidor")
      while True:
        #Recibir la longitud de los datos a recibir
        data_length= recv_exact(worker_socket, 4)
        data_length = struct.unpack('!I', data_length)[0]#Convertir a entero

        #Recibir los datos del servidor
        data=recv_exact(worker_socket,data_length)
        task_data = pickle.loads(data)#Deserializar datos

        #data = worker_socket.recv(4194304)

        print("Tarea recibida...")
        
        #Procesar tarea
        result = process_task(task_data)

        #Enviar el resultado al server
        ser_data=pickle.dumps(result)#Serializar
        data_length=len(ser_data)


        worker_socket.sendall(struct.pack('!I', data_length))#Enviar longitud en formato binario
        worker_socket.sendall(ser_data)#Enviar resultado serializado

        print(" Resultado enviado...")
    except Exception as ex:
        print(f" Error: {ex}")
    finally:
        print("Cerrando conexion")
        worker_socket.close()

if __name__ == "__main__":
    #Iniciar
    print("Iniciando worker")
    start_worker()