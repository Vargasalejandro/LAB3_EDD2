# -*- coding: utf-8 -*-
"""worker-lab3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_Il4R1ATOF6EM7GhbyGWkgolkzco0JW2

CONFIG
"""

CONFIG_PARAMS = {
    'SERVER_IP_ADDRESS': '127.0.0.1',
    'SERVER_PORT': 8081,
    'SERVER_MAX_CLIENTS': 1,
    'SERVER_MAX_WORKERS': 2,
    'EXIT_MESSAGE': 'exit'
}

"""WORKER"""

import socket#Para comunicarse por la red
import time#Manejo del tiempo
import pickle#Para serializacion de datos
import struct#Para manejar datos binarios estructurados

# Configuration Parameters
SERVER_IP_ADDRESS = CONFIG_PARAMS['SERVER_IP_ADDRESS']
SERVER_PORT = CONFIG_PARAMS['SERVER_PORT']
EXIT_MESSAGE = CONFIG_PARAMS['EXIT_MESSAGE']

def Mergesort(vector, start_time, time_limit):
    # Verificar si el tiempo transcurrido ha excedido el límite establecido
    # Si el tiempo límite se ha superado, se devuelve el vector sin ordenar completamente
    if time.perf_counter() - start_time > time_limit:
        return vector  # Devuelve el vector parcialmente ordenado si excede el límite de tiempo

    # Caso base
    if len(vector) <= 1:
        return vector

    # Dividir el vector en dos mitades
    mid = len(vector) // 2  # Se encuentra el índice medio
    # Recursivamente ordena la mitad izquierda del vector
    left = Mergesort(vector[:mid], start_time, time_limit)  # Llamada recursiva sobre la mitad izquierda
    # Recursivamente ordena la mitad derecha del vector.
    right = Mergesort(vector[mid:], start_time, time_limit)  # Llamada recursiva sobre la mitad derecha

    # Antes de mezclar las dos mitades ordenadas, verificamos si el tiempo límite ha sido alcanzado
    # Si el tiempo se ha excedido, se devuelve la mezcla de las dos mitades parcialmente ordenadas
    if time.perf_counter() - start_time > time_limit:
        return left + right  # Devuelve la mezcla de las dos mitades, que aún pueden estar parcialmente ordenadas

    # Si no se ha excedido el tiempo, se mezclan las dos mitades ordenadas
    return merge(left, right)

def merge(left, right):
    # Función auxiliar para mezclar dos listas ordenadas en una lista ordenada
    result = []  # Lista que almacenará los elementos de las dos listas combinadas
    
    # Mientras ambas listas (left y right) tengan elementos, compararlas y añadir el menor a result
    while left and right:
        # Compara el primer elemento de cada lista y añade el más pequeño a result
        if left[0] < right[0]:
            result.append(left.pop(0))  # Elimina y añade el primer elemento de left
        else:
            result.append(right.pop(0))  # Elimina y añade el primer elemento de right

    # Si quedan elementos en left o right (una de las listas podría no estar vacía)
    # los añadimos directamente al final de result
    result.extend(left)  # Añade los elementos restantes de left
    result.extend(right)  # Añade los elementos restantes de right

    # Devuelve la lista combinada y ordenada
    return result



def Heapsort(vector, start_time, time_limit):
    # Obtiene la longitud del vector para calcular el tamaño del heap(monticulo)
    n = len(vector)

    # Construir el heap
    # La construcción del heap comienza desde el último nodo que tiene hijos, es decir, desde n//2 - 1 hacia atrás
    # El heap se construye (asegurandose de que el padre sea mayor que sus hijos)
    for i in range(n // 2 - 1, -1, -1):
        # Verifica si el tiempo ha excedido el límite. Si es así, devuelve el vector parcialmente ordenado
        
        heapify(vector, n, i, start_time, time_limit)  # Llamada a la función heapify para ajustar el heap
        
        if  time.perf_counter() - start_time > time_limit:
            return vector  # Devuelve el vector parcialmente ordenado si se excede el tiempo límite  
    # Extraer elementos del heap y reconstruir el heap en cada paso
    for i in range(n - 1, 0, -1):

        # Verifica si el tiempo ha excedido el límite. Si es así, devuelve el vector parcialmente ordenado
        if  time.perf_counter() - start_time > time_limit:
            return vector  # Devuelve el vector parcialmente ordenado si se excede el tiempo límite
        # Intercambia el primer elemento (máximo) con el último elemento del heap
        vector[i], vector[0] = vector[0], vector[i]

        #Usar heapify para asegurarse que el heap sigue siendo válido después del intercambio
        heapify(vector, i, 0, start_time, time_limit)

    # Devuelve el vector completamente ordenado (si el tiempo no ha excedido el límite)
    return vector


def heapify(arr, n, i, start_time, time_limit):
    # Inicializa la variable 'largest' como el índice del nodo actual
    largest = i
    left = 2 * i + 1  # Índice del hijo izquierdo
    right = 2 * i + 2  # Índice del hijo derecho

    # Si el hijo izquierdo existe y es mayor que el nodo actual, actualiza 'largest'
    if left < n and arr[left] > arr[largest]:
        largest = left
    
    # Si el hijo derecho existe y es mayor que el nodo actual o el hijo izquierdo, actualiza 'largest'
    if right < n and arr[right] > arr[largest]:
        largest = right

    
    # Si largest es diferente del nodo actual, se intercambia el nodo actual con el hijo mayor y llama recursivamente a heapify en el sub-árbol afectado
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # Intercambia el nodo con el hijo mayor
        heapify(arr, n, largest, start_time, time_limit)  # Llama recursivamente a heapify en el sub-árbol afectado


def Quicksort(vector, start_time, time_limit):
    # Verificar si el tiempo límite se ha excedido. Si se ha excedido, devuelve el vector parcialmente ordenado
    if time.perf_counter() - start_time > time_limit:
        return vector  # Devuelve el vector sin cambios si el tiempo ha excedido el límite

    # Caso base
    if len(vector) <= 1:
        return vector

    # Elegir pivote
    pivot = vector[0]

    # Elementos menores o iguales al pivote
    left = [x for x in vector[1:] if x <= pivot]
    
    # Elementos mayores que el pivote
    right = [x for x in vector[1:] if x > pivot]

    # Verificar el tiempo antes de realizar las llamadas recursivas
    # Si se ha excedido el tiempo límite, devuelve la lista parcialmente ordenada
    if time.perf_counter() - start_time > time_limit:
        return left + [pivot] + right  # Devuelve la lista hasta este punto sin ordenar recursivamente

    # Realizar las llamadas con las sublistas(left,right)
    left_sorted = Quicksort(left, start_time, time_limit)
    right_sorted = Quicksort(right, start_time, time_limit)

    # Combina las sublistas ordenadas con el pivote en el medio para devolver el vector ordenado
    return left_sorted + [pivot] + right_sorted

def split_sorted_unsorted(vector):
    #Divide un vector en su parte ordenada y desordenada
    for i in range(1, len(vector)):
        if vector[i] < vector[i - 1]:
            # Se encuentra donde el vector ya no esta ordenado
            return vector[:i], vector[i:]
    return vector, []  # Si todo esta ordenado

def process_task(task_data):
    #Organizar los datosrecibidos
    vector = task_data["unsorted_vector"]#Parte desordenada
    sorted=task_data["sorted_vector"]#Parte ordenada
    algoritmo=task_data["algoritmo"]
    time_limit=task_data["time_limit"]

    #Obtener el tiempo de inicio
    start_time=time.perf_counter()

    #Determinar el algoritmo de procesamiento
    print("Ordenando el vector")
    if algoritmo==1:
      vector=Mergesort(vector,start_time,time_limit)
    elif algoritmo==2:
      vector=Heapsort(vector,start_time,time_limit)
    elif algoritmo==3:
      vector=Quicksort(vector,start_time,time_limit)

    #Calcular el tiempo que se demoro el worker
    time_taken=time.perf_counter()-start_time

    print("Dividiendo el vector en parte ordenada y desordenada")
    #Del vector que justo se ordeno, se divide en una parte ordenada y otra desordenada
    vector,unsorted=split_sorted_unsorted(vector)
    #Las dos partes ordenadas se mezclan, la desordenada permanece aparte
    print("Obteniendo la nueva parte ordenada del vector")
    sorted=merge(sorted,vector)

    #CHECK
    #print("sorted:",len(sorted))
    #print("unsorted:",len(unsorted))
    
    #Determinar si se complete la tarea 
    if time_taken>time_limit:
      return {"sorted_vector": sorted, "time_taken": time_taken,"completed":False,"unsorted_vector":unsorted,"algoritmo":algoritmo,"time_limit":time_limit}
    else:
      return {"sorted_vector": sorted, "time_taken": time_taken,"completed":True,"unsorted_vector":unsorted}

def recv_exact(socket, n):
    #Recibir exactamente n bytes desde socket, debido a que habia problemas si no recibia todos los bytes a la vez
    data = b''
    while len(data) < n:
        chunk = socket.recv(n - len(data))
        if not chunk:
            raise Exception("Conexión cerrada antes de recibir todos los datos.")
        data += chunk
    return data

def start_worker():

    try:
      print("Intentando conectarse con el servidor")
      worker_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
      worker_socket.connect((SERVER_IP_ADDRESS, SERVER_PORT))  # Conexión al servidor
      print("Conexion establecida con el servidor")
      while True:
        #Recibir la longitud de los datos a recibir
        data_length= recv_exact(worker_socket, 4)
        data_length = struct.unpack('!I', data_length)[0]#Convertir a entero

        #Recibir los datos del servidor
        data=recv_exact(worker_socket,data_length)
        task_data = pickle.loads(data)#Deserializar datos

        #data = worker_socket.recv(4194304)

        print("Tarea recibida...")
        
        #Procesar tarea
        result = process_task(task_data)

        #Enviar el resultado al server
        ser_data=pickle.dumps(result)#Serializar
        data_length=len(ser_data)


        worker_socket.sendall(struct.pack('!I', data_length))#Enviar longitud en formato binario
        worker_socket.sendall(ser_data)#Enviar resultado serializado

        print(" Resultado enviado...")
    except Exception as ex:
        print(f" Error: {ex}")
    finally:
        print("Cerrando conexion")
        worker_socket.close()

if __name__ == "__main__":
    #Iniciar
    print("Iniciando worker")
    start_worker()